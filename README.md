# Brilliant Build

*This is a work in progress.*

A build system that aims to be scalable, correct, and easy to use. Note that
this is *not* also a package manager.

## "Ugh! Another build system? [Why?!][relevant xkcd]"

[relevant xkcd]: https://xkcd.com/927/

Because, of the hundreds of build systems out there, the vast majority of them
are pretty terrible. They tend to suffer from a set of common ailments:

 * They don't do correct incremental builds.
 * They don't correctly track changes to the build description.
 * They don't scale well with huge projects.
 * They are language-specific or aren't general enough.
 * They have a horrendous build description language (e.g., Make).

Brilliant Build is designed such that it can solve all of these problems.
However, time will tell if this is actually true in practice.

## Quick Example

### Build Description

Here is a simple example of a build description:

```json
{
    "rules": [
        {
            "inputs": ["foo.c", "baz.h"],
            "task": ["gcc", "-c", "foo.c", "-o", "foo.o"],
            "outputs": ["foo.o"]
        },
        {
            "inputs": ["bar.c", "baz.h"],
            "task": ["gcc", "-c", "bar.c", "-o", "bar.o"],
            "outputs": ["bar.o"]
        },
        {
            "inputs": ["foo.o", "bar.o"],
            "task": ["gcc", "foo.o", "bar.o", "-o", "foobar"],
            "outputs": ["foobar"]
        }
    ]
}
```

If this file is named `bb.json`, Brilliant Build will automatically find it.

Note that build descriptions are not intended to be written by hand. For
projects more complicated than this, one should generate the build description.
Note that Brilliant Build can be used as a task in a "root" build description to
help achieve this.

### Visualizing the Build

A visualization of the above build description can be generated using
[GraphViz][]:

```bash
$ bb graph | dot -Tpng > basic.png
```
![Simple Task Graph](/docs/examples/basic/build.png)

[GraphViz]: http://www.graphviz.org/

### Running the Build

Suppose this is our first time running the build. In that case, we will see a
full build:

```bash
$ bb update
 > gcc -c bar.c -o bar.o
 > gcc -c foo.c -o foo.o
 > gcc foo.o bar.o -o foobar
```

If we run it again immediately without changing any files, nothing will happen:

```bash
$ bb update
```

Now suppose we make a change to the file `foo.c` and run the build again. Only
the necessary tasks to bring the outputs up-to-date are executed:

```bash
$ touch foo.c
$ bb update
 > gcc -c foo.c -o foo.o
 > gcc foo.o bar.o -o foobar
```

## Planned Features

All of the above is already implemented. Below gives rough details on what will
eventually be implemented in order of descending priority.

### Automatic, implicit dependencies

Currently, there is no way to discover dependencies while the build is running.
Everything must be specified explicitly up front before any tasks are executed.

To achieve the discovery of implicit dependencies, the task that is running will
be able to send a list of inputs and outputs to Brilliant Build. Brilliant Build
will then add these to the build graph.

This means that "wrapper" tasks must be created for common programs such as
`gcc` to discover dependencies. It would also be possible to use `strace` as a
fallback to discover all possible file dependencies.

### Convenient way to generate build descriptions

Currently, the JSON build description must be written by hand. This should
almost never be necessary. The build description should always be generated by
some other program.

The idea is to write libraries in one or more scripting languages (e.g., Lua and
Python) that help in generating the JSON build description.

### File system monitoring

Since the set of input files is known, these can be monitored for changes. When
one such file changes, a build can be started automatically to bring the outputs
up to date. There should be one daemon per build description.

### Tool to translate other build descriptions to this one

Since the JSON build description is very general, theoretically a build
description from another build system (e.g., Make, MSBuild) could be translated
automatically.

This would greatly aid in transitioning away from the build system currently in
use.

### Web interface

A web interface for running and visualizing builds could be extremely useful. In
such an interface, one should be able to click a button to start and stop a
build. A graph of the build should be displayed and updated in real time. A
search function should be available for finding nodes in the graph. One should
also be able to "walk" the nodes in the graph. Clicking on a node should display
its `stderr` and `stdout` log.

### Thorough documentation

A website hosting documentation on all things related to building software. This
includes:

 * Starting build descriptions for certain types of projects
 * Fundamental concepts of a build system
 * Tutorials on various topics

## License

[MIT License](/LICENSE.md)
