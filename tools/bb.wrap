#!/bin/env python3

# Copyright: Copyright Jason White, 2015
# License:   MIT
# Authors:   Jason White
#
# Description:
# Standalone tool that wraps various programs to efficiently capture their
# dependencies and send them to Brilliant Build.
import sys
import os
import tempfile
import subprocess
import re

try:
    finputs  = os.fdopen(int(os.environ['BRILLIANT_BUILD_INPUTS']),  'w')
    foutputs = os.fdopen(int(os.environ['BRILLIANT_BUILD_OUTPUTS']), 'w')

    def add_input(path):
        finputs.write(path)
        finputs.write('\0')
        finputs.flush()

    def add_output(path):
        foutputs.write(path)
        foutputs.write('\0')
        foutputs.flush()
except:
    def add_input(path):
        pass

    def add_output(path):
        pass

def add_inputs(paths):
    for p in paths:
        add_input(p)

def add_outputs(paths):
    for p in paths:
        add_output(p)

def parse_dmd_deps(f):
    """
    Parses a DMD dependency file.
    """
    pattern = re.compile(r'\((.*?)\)')

    for line in f:
        for m in pattern.finditer(line):
            yield m.group(1)

def dmd(args):
    """
    The Digital Mars D compiler.

    We add the '-deps' option to determine inputs.
    """

    deps = [x for x in enumerate(args) if x[1].startswith('-deps=')]

    if len(deps) > 1:
        print("Error: Found multiple '-deps=' options", file=sys.stderr)
        sys.exit(1)

    if deps:
        print("FIXME: Support -deps being in the command line", file=sys.stderr)
        sys.exit(1)

    # Create a temporary file to write dependencies to
    f, temp = tempfile.mkstemp()
    os.close(f)

    args.append('-deps=' + temp)

    proc = subprocess.run(args)

    with open(temp) as f:
        add_inputs(set(parse_dmd_deps(f)))

    add_outputs([x[3:] for x in args if x.startswith('-of')])

    os.remove(temp)

    return proc.returncode

# List of supported programs and their handlers.
tools = {
        'dmd': dmd,
    }

if __name__ == '__main__':
    try:
        sys.exit(tools[sys.argv[1]](sys.argv[1:]))
    except KeyError as e:
        print('Error:', e, 'is not a supported tool', file=sys.stderr)
        sys.exit(1)
